{"ast":null,"code":"import axios from \"axios\";\n\n// Map for localstorage keys\nconst LOCALSTORAGE_KEYS = {\n  accessToken: \"spotify_access_token\",\n  refreshToken: \"spotify_refresh_token\",\n  expireTime: \"spotify_token_expire_time\",\n  timestamp: \"spotify_token_timestamp\"\n};\n\n// Map to retrieve localstorage values\nconst LOCALSTORAGE_VALUES = {\n  accessToken: window.localStorage.getItem(LOCALSTORAGE_KEYS.accessToken),\n  refreshToken: window.localStorage.getItem(LOCALSTORAGE_KEYS.refreshToken),\n  expireTime: window.localStorage.getItem(LOCALSTORAGE_KEYS.expireTime),\n  timestamp: window.localStorage.getItem(LOCALSTORAGE_KEYS.timestamp)\n};\n\n/**\r\n * Checks if the amount of time that has elapesed between the timestamp in localstorage and \r\n * now is greater than the expiration time of 3600 seconds (1 hour)\r\n * @returns {boolean} whether or not the access token in localstorage has expired\r\n */\nconst hasTokenExpired = () => {\n  const {\n    accessToken,\n    timestamp,\n    expireTime\n  } = LOCALSTORAGE_VALUES;\n  if (!accessToken || !timestamp) {\n    return false;\n  }\n  const millisecondsElapsed = Date.now() - Number(timestamp);\n  return millisecondsElapsed / 1000 > Number(expireTime);\n};\n\n/**\r\n * Use the refresh token in localStorage to hit the /refresh_token endpointin our Node app,\r\n * then update values in localstorage with data form response\r\n * @returns {void}\r\n */\nconst refreshToken = async () => {\n  try {\n    // Logout if there's no refresh token stored or we've managed to get into a reload infinite loop\n    if (!LOCALSTORAGE_VALUES.refreshToken || LOCALSTORAGE_VALUES.refreshToken === 'undefined' || Date.now() - Number(LOCALSTORAGE_VALUES.timestamp) / 1000 < 1000) {\n      console.error('No refresh token available');\n      logout();\n    }\n\n    // Use '/refresh_token' endpoint from our Node App\n    const {\n      data\n    } = await axios.get(`/refresh_token? refresh_token=${LOCALSTORAGE_KEYS.refreshToken}`);\n\n    // Update localStorage values\n    window.localStorage.setItem(LOCALSTORAGE_KEYS.accessToken, data.access_token);\n    window.localStorage.setItem(LOCALSTORAGE_KEYS.timestamp, Date.now());\n\n    // Reload the page for localStorage updates to be reflected\n    window.location.reload();\n  } catch (e) {\n    console.error(e);\n  }\n};\n\n/**\r\n * Handles logic for retrieving the Spotify access token from localstorage or URL query params\r\n * @returns {string} a Spotify access token\r\n */\nconst getAccessToken = () => {\n  const queryString = window.localStorage.search;\n  const urlParams = new URLSearchParams(queryString);\n  const queryParams = {\n    [LOCALSTORAGE_KEYS.accessToken]: urlParams.get(\"access_token\"),\n    [LOCALSTORAGE_KEYS.refreshToken]: urlParams.get(\"refresh_token\"),\n    [LOCALSTORAGE_KEYS.expireTime]: urlParams.get(\"expires_in\")\n  };\n  const hasError = urlParams.get(\"error\");\n\n  // If there's an error OR the token in localstorage has expired, refresh the token\n  if (hasError || hasTokenExpired() || LOCALSTORAGE_VALUES.accessToken === \"undefined\") {\n    refreshToken();\n  }\n\n  // If there is a valid access token in localstorage, use it\n  if (LOCALSTORAGE_VALUES.accessToken && LOCALSTORAGE_VALUES.accessToken !== \"undefined\") {\n    return LOCALSTORAGE_VALUES.accessToken;\n  }\n\n  // If there is a token in the URL query params, user is logging in for the first time\n  if (queryParams[LOCALSTORAGE_KEYS.accessToken]) {\n    // Store the query params in localstorage\n    for (const property in queryParams) {\n      window.localStorage.setItem(property, queryParams[property]);\n    }\n\n    // Set timestamp\n    window.localStorage.setItem(LOCALSTORAGE_KEYS.timestamp, Date.now());\n    // Return access token from query params\n    return queryParams[LOCALSTORAGE_KEYS.accessToken];\n  }\n  return false;\n};\nexport const accessToken = getAccessToken();","map":{"version":3,"names":["axios","LOCALSTORAGE_KEYS","accessToken","refreshToken","expireTime","timestamp","LOCALSTORAGE_VALUES","window","localStorage","getItem","hasTokenExpired","millisecondsElapsed","Date","now","Number","console","error","logout","data","get","setItem","access_token","location","reload","e","getAccessToken","queryString","search","urlParams","URLSearchParams","queryParams","hasError","property"],"sources":["C:/Users/qlamb/Desktop/Projects/spotify-app/client/src/spotify.js"],"sourcesContent":["import axios from \"axios\";\r\n\r\n// Map for localstorage keys\r\nconst LOCALSTORAGE_KEYS = {\r\n  accessToken: \"spotify_access_token\",\r\n  refreshToken: \"spotify_refresh_token\",\r\n  expireTime: \"spotify_token_expire_time\",\r\n  timestamp: \"spotify_token_timestamp\",\r\n};\r\n\r\n// Map to retrieve localstorage values\r\nconst LOCALSTORAGE_VALUES = {\r\n  accessToken: window.localStorage.getItem(LOCALSTORAGE_KEYS.accessToken),\r\n  refreshToken: window.localStorage.getItem(LOCALSTORAGE_KEYS.refreshToken),\r\n  expireTime: window.localStorage.getItem(LOCALSTORAGE_KEYS.expireTime),\r\n  timestamp: window.localStorage.getItem(LOCALSTORAGE_KEYS.timestamp),\r\n};\r\n\r\n/**\r\n * Checks if the amount of time that has elapesed between the timestamp in localstorage and \r\n * now is greater than the expiration time of 3600 seconds (1 hour)\r\n * @returns {boolean} whether or not the access token in localstorage has expired\r\n */\r\nconst hasTokenExpired = () => {\r\n    const { accessToken, timestamp, expireTime } = LOCALSTORAGE_VALUES;\r\n\r\n    if(!accessToken || !timestamp){\r\n        return false;\r\n    }\r\n    const millisecondsElapsed = Date.now() - Number(timestamp);\r\n\r\n    return (millisecondsElapsed / 1000) > Number(expireTime)\r\n}\r\n\r\n/**\r\n * Use the refresh token in localStorage to hit the /refresh_token endpointin our Node app,\r\n * then update values in localstorage with data form response\r\n * @returns {void}\r\n */\r\nconst refreshToken = async () => {\r\n    try{\r\n        // Logout if there's no refresh token stored or we've managed to get into a reload infinite loop\r\n        if(!LOCALSTORAGE_VALUES.refreshToken || LOCALSTORAGE_VALUES.refreshToken === 'undefined' || (Date.now() - Number(LOCALSTORAGE_VALUES.timestamp)/1000) < 1000){\r\n            console.error('No refresh token available');\r\n            logout();\r\n        }\r\n\r\n        // Use '/refresh_token' endpoint from our Node App\r\n        const { data } = await axios.get(`/refresh_token? refresh_token=${LOCALSTORAGE_KEYS.refreshToken}`)\r\n\r\n        // Update localStorage values\r\n        window.localStorage.setItem(LOCALSTORAGE_KEYS.accessToken, data.access_token);\r\n        window.localStorage.setItem(LOCALSTORAGE_KEYS.timestamp, Date.now());\r\n\r\n        // Reload the page for localStorage updates to be reflected\r\n        window.location.reload();\r\n        \r\n    } catch(e) {\r\n        console.error(e);\r\n    }\r\n}\r\n\r\n/**\r\n * Handles logic for retrieving the Spotify access token from localstorage or URL query params\r\n * @returns {string} a Spotify access token\r\n */\r\nconst getAccessToken = () => {\r\n  const queryString = window.localStorage.search;\r\n  const urlParams = new URLSearchParams(queryString);\r\n  const queryParams = {\r\n    [LOCALSTORAGE_KEYS.accessToken]: urlParams.get(\"access_token\"),\r\n    [LOCALSTORAGE_KEYS.refreshToken]: urlParams.get(\"refresh_token\"),\r\n    [LOCALSTORAGE_KEYS.expireTime]: urlParams.get(\"expires_in\"),\r\n  };\r\n  const hasError = urlParams.get(\"error\");\r\n\r\n  // If there's an error OR the token in localstorage has expired, refresh the token\r\n  if (\r\n    hasError ||\r\n    hasTokenExpired() ||\r\n    LOCALSTORAGE_VALUES.accessToken === \"undefined\"\r\n  ) {\r\n    refreshToken();\r\n  }\r\n\r\n  // If there is a valid access token in localstorage, use it\r\n  if (\r\n    LOCALSTORAGE_VALUES.accessToken &&\r\n    LOCALSTORAGE_VALUES.accessToken !== \"undefined\"\r\n  ) {\r\n    return LOCALSTORAGE_VALUES.accessToken;\r\n  }\r\n\r\n  // If there is a token in the URL query params, user is logging in for the first time\r\n  if (queryParams[LOCALSTORAGE_KEYS.accessToken]) {\r\n    // Store the query params in localstorage\r\n    for (const property in queryParams) {\r\n      window.localStorage.setItem(property, queryParams[property]);\r\n    }\r\n\r\n    // Set timestamp\r\n    window.localStorage.setItem(LOCALSTORAGE_KEYS.timestamp, Date.now());\r\n    // Return access token from query params\r\n    return queryParams[LOCALSTORAGE_KEYS.accessToken];\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nexport const accessToken = getAccessToken();\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}