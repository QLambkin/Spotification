{"ast":null,"code":"import axios from \"axios\";\n\n// Map for localStorage keys\nconst LOCALSTORAGE_KEYS = {\n  accessToken: \"spotify_access_token\",\n  refreshToken: \"spotify_refresh_token\",\n  expireTime: \"spotify_token_expire_time\",\n  timestamp: \"spotify_token_timestamp\"\n};\n\n// Map to retrieve localStorage values\nconst LOCALSTORAGE_VALUES = {\n  accessToken: window.localStorage.getItem(LOCALSTORAGE_KEYS.accessToken),\n  refreshToken: window.localStorage.getItem(LOCALSTORAGE_KEYS.refreshToken),\n  expireTime: window.localStorage.getItem(LOCALSTORAGE_KEYS.expireTime),\n  timestamp: window.localStorage.getItem(LOCALSTORAGE_KEYS.timestamp)\n};\n\n/**\r\n * Clear out all localStorage items we've set and reload the page\r\n * @returns {void}\r\n */\nexport const logout = () => {\n  // Clear all localStorage items\n  for (const property in LOCALSTORAGE_KEYS) {\n    window.localStorage.removeItem(LOCALSTORAGE_KEYS[property]);\n  }\n  // Navigate to homepage\n  window.location = window.location.origin;\n};\n\n/**\r\n * Use the refresh token in localStorage to hit the /refresh_token endpoint\r\n * in our Node app, then update values in localStorage with data from response.\r\n * @returns {void}\r\n */\nconst refreshToken = async () => {\n  try {\n    // Logout if there's no refresh token stored or we've managed to get into a reload infinite loop\n    if (!LOCALSTORAGE_VALUES.refreshToken || LOCALSTORAGE_VALUES.refreshToken === \"undefined\" || Date.now() - Number(LOCALSTORAGE_VALUES.timestamp) / 1000 < 1000) {\n      console.error(\"No refresh token available\");\n      logout();\n    }\n\n    // Use `/refresh_token` endpoint from our Node app\n    const {\n      data\n    } = await axios.get(`/refresh_token?refresh_token=${LOCALSTORAGE_VALUES.refreshToken}`);\n\n    // Update localStorage values\n    window.localStorage.setItem(LOCALSTORAGE_KEYS.accessToken, data.access_token);\n    window.localStorage.setItem(LOCALSTORAGE_KEYS.timestamp, Date.now());\n\n    // Reload the page for localStorage updates to be reflected\n    window.location.reload();\n  } catch (e) {\n    console.error(e);\n  }\n};\n\n/**\r\n * Checks if the amount of time that has elapsed between the timestamp in localStorage\r\n * and now is greater than the expiration time of 3600 seconds (1 hour).\r\n * @returns {boolean} Whether or not the access token in localStorage has expired\r\n */\nconst hasTokenExpired = () => {\n  const {\n    accessToken,\n    timestamp,\n    expireTime\n  } = LOCALSTORAGE_VALUES;\n  if (!accessToken || !timestamp) {\n    return false;\n  }\n  const millisecondsElapsed = Date.now() - Number(timestamp);\n  return millisecondsElapsed / 1000 > Number(expireTime);\n};\n\n/**\r\n * Handles logic for retrieving the Spotify access token from localStorage\r\n * or URL query params\r\n * @returns {string} A Spotify access token\r\n */\nconst getAccessToken = () => {\n  const queryString = window.location.search;\n  const urlParams = new URLSearchParams(queryString);\n  const queryParams = {\n    [LOCALSTORAGE_KEYS.accessToken]: urlParams.get(\"access_token\"),\n    [LOCALSTORAGE_KEYS.refreshToken]: urlParams.get(\"refresh_token\"),\n    [LOCALSTORAGE_KEYS.expireTime]: urlParams.get(\"expires_in\")\n  };\n  const hasError = urlParams.get(\"error\");\n\n  // If there's an error OR the token in localStorage has expired, refresh the token\n  if (hasError || hasTokenExpired() || LOCALSTORAGE_VALUES.accessToken === \"undefined\") {\n    refreshToken();\n  }\n\n  // If there is a valid access token in localStorage, use that\n  if (LOCALSTORAGE_VALUES.accessToken && LOCALSTORAGE_VALUES.accessToken !== \"undefined\") {\n    return LOCALSTORAGE_VALUES.accessToken;\n  }\n\n  // If there is a token in the URL query params, user is logging in for the first time\n  if (queryParams[LOCALSTORAGE_KEYS.accessToken]) {\n    // Store the query params in localStorage\n    for (const property in queryParams) {\n      window.localStorage.setItem(property, queryParams[property]);\n    }\n    // Set timestamp\n    window.localStorage.setItem(LOCALSTORAGE_KEYS.timestamp, Date.now());\n    // Return access token from query params\n    return queryParams[LOCALSTORAGE_KEYS.accessToken];\n  }\n\n  // We should never get here!\n  return false;\n};\nexport const accessToken = getAccessToken();\n\n/**\r\n * Axios global request headers\r\n */\naxios.defaults.baseURL = \"https://api.spotify.com/v1\";\naxios.defaults.headers[\"Authorization\"] = `Bearer ${accessToken}`;\naxios.defaults.headers[\"Content-Type\"] = \"application/json\";\n\n/**\r\n * Get Current User's Profile\r\n * https://developer.spotify.com/documentation/web-api/reference/#endpoint-get-current-users-profile\r\n * @returns {Promise}\r\n */\nexport const getCurrentUserProfile = () => axios.get(\"/me\");\n\n/**\r\n * Get a List of Current User's Playlists\r\n * https://developer.spotify.com/documentation/web-api/reference/#endpoint-get-a-list-of-current-users-playlists\r\n * @returns {Promise}\r\n */\nexport const getCurrentUserPlaylists = function () {\n  let limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 20;\n  return axios.get(`/me/playlists?limit=${limit}`);\n};\n\n/**\r\n * Get a User's Top Artists\r\n * https://developer.spotify.com/documentation/web-api/reference/#endpoint-get-users-top-artists-and-tracks\r\n * @param {string} time_range - 'short_term' (last 4 weeks) 'medium_term' (last 6 months) or 'long_term' (calculated from several years of data and including all new data as it becomes available). Defaults to 'short_term'\r\n * @returns {Promise}\r\n */\nexport const getTopArtists = function () {\n  let time_range = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"short_term\";\n  return axios.get(`/me/top/artists?time_range=${time_range}`);\n};\n\n/**\r\n * Get a User's Top Tracks\r\n * https://developer.spotify.com/documentation/web-api/reference/#endpoint-get-users-top-artists-and-tracks\r\n * @param {string} time_range - 'short_term' (last 4 weeks) 'medium_term' (last 6 months) or 'long_term' (calculated from several years of data and including all new data as it becomes available). Defaults to 'short_term'\r\n * @returns {Promise}\r\n */\nexport const getTopTracks = function () {\n  let time_range = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"short_term\";\n  return axios.get(`/me/top/tracks?time_range=${time_range}`);\n};","map":{"version":3,"names":["axios","LOCALSTORAGE_KEYS","accessToken","refreshToken","expireTime","timestamp","LOCALSTORAGE_VALUES","window","localStorage","getItem","logout","property","removeItem","location","origin","Date","now","Number","console","error","data","get","setItem","access_token","reload","e","hasTokenExpired","millisecondsElapsed","getAccessToken","queryString","search","urlParams","URLSearchParams","queryParams","hasError","defaults","baseURL","headers","getCurrentUserProfile","getCurrentUserPlaylists","limit","getTopArtists","time_range","getTopTracks"],"sources":["C:/Users/qlamb/Desktop/Projects/spotify-app/client/src/spotify.js"],"sourcesContent":["import axios from \"axios\";\r\n\r\n// Map for localStorage keys\r\nconst LOCALSTORAGE_KEYS = {\r\n  accessToken: \"spotify_access_token\",\r\n  refreshToken: \"spotify_refresh_token\",\r\n  expireTime: \"spotify_token_expire_time\",\r\n  timestamp: \"spotify_token_timestamp\",\r\n};\r\n\r\n// Map to retrieve localStorage values\r\nconst LOCALSTORAGE_VALUES = {\r\n  accessToken: window.localStorage.getItem(LOCALSTORAGE_KEYS.accessToken),\r\n  refreshToken: window.localStorage.getItem(LOCALSTORAGE_KEYS.refreshToken),\r\n  expireTime: window.localStorage.getItem(LOCALSTORAGE_KEYS.expireTime),\r\n  timestamp: window.localStorage.getItem(LOCALSTORAGE_KEYS.timestamp),\r\n};\r\n\r\n/**\r\n * Clear out all localStorage items we've set and reload the page\r\n * @returns {void}\r\n */\r\nexport const logout = () => {\r\n  // Clear all localStorage items\r\n  for (const property in LOCALSTORAGE_KEYS) {\r\n    window.localStorage.removeItem(LOCALSTORAGE_KEYS[property]);\r\n  }\r\n  // Navigate to homepage\r\n  window.location = window.location.origin;\r\n};\r\n\r\n/**\r\n * Use the refresh token in localStorage to hit the /refresh_token endpoint\r\n * in our Node app, then update values in localStorage with data from response.\r\n * @returns {void}\r\n */\r\nconst refreshToken = async () => {\r\n  try {\r\n    // Logout if there's no refresh token stored or we've managed to get into a reload infinite loop\r\n    if (\r\n      !LOCALSTORAGE_VALUES.refreshToken ||\r\n      LOCALSTORAGE_VALUES.refreshToken === \"undefined\" ||\r\n      Date.now() - Number(LOCALSTORAGE_VALUES.timestamp) / 1000 < 1000\r\n    ) {\r\n      console.error(\"No refresh token available\");\r\n      logout();\r\n    }\r\n\r\n    // Use `/refresh_token` endpoint from our Node app\r\n    const { data } = await axios.get(\r\n      `/refresh_token?refresh_token=${LOCALSTORAGE_VALUES.refreshToken}`\r\n    );\r\n\r\n    // Update localStorage values\r\n    window.localStorage.setItem(\r\n      LOCALSTORAGE_KEYS.accessToken,\r\n      data.access_token\r\n    );\r\n    window.localStorage.setItem(LOCALSTORAGE_KEYS.timestamp, Date.now());\r\n\r\n    // Reload the page for localStorage updates to be reflected\r\n    window.location.reload();\r\n  } catch (e) {\r\n    console.error(e);\r\n  }\r\n};\r\n\r\n/**\r\n * Checks if the amount of time that has elapsed between the timestamp in localStorage\r\n * and now is greater than the expiration time of 3600 seconds (1 hour).\r\n * @returns {boolean} Whether or not the access token in localStorage has expired\r\n */\r\nconst hasTokenExpired = () => {\r\n  const { accessToken, timestamp, expireTime } = LOCALSTORAGE_VALUES;\r\n  if (!accessToken || !timestamp) {\r\n    return false;\r\n  }\r\n  const millisecondsElapsed = Date.now() - Number(timestamp);\r\n  return millisecondsElapsed / 1000 > Number(expireTime);\r\n};\r\n\r\n/**\r\n * Handles logic for retrieving the Spotify access token from localStorage\r\n * or URL query params\r\n * @returns {string} A Spotify access token\r\n */\r\nconst getAccessToken = () => {\r\n  const queryString = window.location.search;\r\n  const urlParams = new URLSearchParams(queryString);\r\n  const queryParams = {\r\n    [LOCALSTORAGE_KEYS.accessToken]: urlParams.get(\"access_token\"),\r\n    [LOCALSTORAGE_KEYS.refreshToken]: urlParams.get(\"refresh_token\"),\r\n    [LOCALSTORAGE_KEYS.expireTime]: urlParams.get(\"expires_in\"),\r\n  };\r\n  const hasError = urlParams.get(\"error\");\r\n\r\n  // If there's an error OR the token in localStorage has expired, refresh the token\r\n  if (\r\n    hasError ||\r\n    hasTokenExpired() ||\r\n    LOCALSTORAGE_VALUES.accessToken === \"undefined\"\r\n  ) {\r\n    refreshToken();\r\n  }\r\n\r\n  // If there is a valid access token in localStorage, use that\r\n  if (\r\n    LOCALSTORAGE_VALUES.accessToken &&\r\n    LOCALSTORAGE_VALUES.accessToken !== \"undefined\"\r\n  ) {\r\n    return LOCALSTORAGE_VALUES.accessToken;\r\n  }\r\n\r\n  // If there is a token in the URL query params, user is logging in for the first time\r\n  if (queryParams[LOCALSTORAGE_KEYS.accessToken]) {\r\n    // Store the query params in localStorage\r\n    for (const property in queryParams) {\r\n      window.localStorage.setItem(property, queryParams[property]);\r\n    }\r\n    // Set timestamp\r\n    window.localStorage.setItem(LOCALSTORAGE_KEYS.timestamp, Date.now());\r\n    // Return access token from query params\r\n    return queryParams[LOCALSTORAGE_KEYS.accessToken];\r\n  }\r\n\r\n  // We should never get here!\r\n  return false;\r\n};\r\n\r\nexport const accessToken = getAccessToken();\r\n\r\n/**\r\n * Axios global request headers\r\n */\r\naxios.defaults.baseURL = \"https://api.spotify.com/v1\";\r\naxios.defaults.headers[\"Authorization\"] = `Bearer ${accessToken}`;\r\naxios.defaults.headers[\"Content-Type\"] = \"application/json\";\r\n\r\n/**\r\n * Get Current User's Profile\r\n * https://developer.spotify.com/documentation/web-api/reference/#endpoint-get-current-users-profile\r\n * @returns {Promise}\r\n */\r\nexport const getCurrentUserProfile = () => axios.get(\"/me\");\r\n\r\n/**\r\n * Get a List of Current User's Playlists\r\n * https://developer.spotify.com/documentation/web-api/reference/#endpoint-get-a-list-of-current-users-playlists\r\n * @returns {Promise}\r\n */\r\nexport const getCurrentUserPlaylists = (limit = 20) => {\r\n  return axios.get(`/me/playlists?limit=${limit}`);\r\n};\r\n\r\n/**\r\n * Get a User's Top Artists\r\n * https://developer.spotify.com/documentation/web-api/reference/#endpoint-get-users-top-artists-and-tracks\r\n * @param {string} time_range - 'short_term' (last 4 weeks) 'medium_term' (last 6 months) or 'long_term' (calculated from several years of data and including all new data as it becomes available). Defaults to 'short_term'\r\n * @returns {Promise}\r\n */\r\nexport const getTopArtists = (time_range = \"short_term\") => {\r\n  return axios.get(`/me/top/artists?time_range=${time_range}`);\r\n};\r\n\r\n/**\r\n * Get a User's Top Tracks\r\n * https://developer.spotify.com/documentation/web-api/reference/#endpoint-get-users-top-artists-and-tracks\r\n * @param {string} time_range - 'short_term' (last 4 weeks) 'medium_term' (last 6 months) or 'long_term' (calculated from several years of data and including all new data as it becomes available). Defaults to 'short_term'\r\n * @returns {Promise}\r\n */\r\nexport const getTopTracks = (time_range = \"short_term\") => {\r\n  return axios.get(`/me/top/tracks?time_range=${time_range}`);\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}